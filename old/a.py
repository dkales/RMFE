
# This file was *autogenerated* from the file a.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4)#!/usr/bin/env sage

from FFTpreproc import *
from FFTa import * 
from field_iso import *
from twostepinstance import *
from polyintereval import *

#map23: phi-map of (k1,e1)_2-RMFE

def phi_first(v,instance):
	a=instance.a
	if instance.k1==_sage_const_2 : 	 
  		return v[_sage_const_0 ]+(v[_sage_const_0 ]+v[_sage_const_1 ])*a
	elif instance.k1==_sage_const_3 :
		return v[_sage_const_0 ]+(-v[_sage_const_0 ]+v[_sage_const_1 ]-v[_sage_const_2 ])*a+v[_sage_const_2 ]*a**_sage_const_2 
#invmap23: psi-map of (2,3)_2-RMFE

def psi_first(d,instance):
	P=instance.P
	X=instance.X
	if d==[]:
		return []	
	if d!=_sage_const_0 :
		p=d.polynomial(X)
		r=[p(_sage_const_0 ),p(_sage_const_1 )]
		if instance.k1==_sage_const_3 :
			r.append(p[_sage_const_4 ])
		return r		
	else:
		return ([_sage_const_0 ]*instance.k1)



#phi_RMFE23: If given a binary vector of length k<=18, computes phi-map of (k,51)_2-RMFE. Else, split in blocks of length 18 (and a remainder block of length k') and compute phi-map of (18,51)_2-RMFE on each block (and (k',51)_2-RMFE on the last one). Outputs a list of elements in GF(2^51)

def phi_RMFE(v,instance): 
	k1=instance.k1
	k2=instance.k2
	e1=instance.e1
	e2=instance.e2
	k=instance.k
	e=instance.e
	m1=instance.m1
	m2=instance.m2
	F=instance.F
	a=instance.a
	H=instance.H
	c=instance.c
	P=instance.P
	X=instance.X
	R=instance.R
	Y=instance.Y
	f=instance.f
	h=instance.h
	g=instance.g
	if len(v)>k:
        #If the vector is of length >18, then split the vector in blocks of 18, apply map to each block.
		w=[]
		number_blocks=len(v)//k+_sage_const_1 
		for i in range(number_blocks-_sage_const_1 ):
			w.append(v[k*i:k*i+k])
		w.append(v[k*(number_blocks-_sage_const_1 ):])
		res=[]
		for j in range(len(w)):
			
			res=res+phi_RMFE(w[j],instance)
			
		return res
    
	else:
    	#Split the binary vector in blocks of k1 cordinates (fill in left-over block with zeros), apply (k1,e1)_2-RMFE to each block. 
		k=len(v)
		leftover=k%k1
    		
		l=_sage_const_0 
		for i in range(leftover):
			v.append(_sage_const_0 )
			l+=_sage_const_1 	
	    	
		v1=[]
	    	
		for i in range((k+l)//k1):
			#print(v[k1*i:k1*i+2])
			t=phi_first(v[k1*i:k1*i+k1],instance)
			v1.append(t)            
   	#Second step, apply (k',e2)_2^e1-RMFE to result v1.
    	
    	#Interpolate
	p=interpol(v1,instance)
    	    
    	#Map the <=15-degree polynomial from F_16[X] into an element of F_(2^128) via field_iso_desc  (by implicitely first mapping into an element of F_(16^32) and then changing to a representation in F_2^(128)).    
	r=field_iso_desc(p,e1,g,h,F,H,P,R)
            
    	
	return [r]





#psi_RMFE23: Given a list of elements w of F_(2^51), and a vector of values vk<=18, computes psi-map of (vk,51)_2-RMFE on each element and outputs the concatenation of the resulting vectors

def psi_RMFE(w,vk,instance):
	k1=instance.k1
	k2=instance.k2
	e1=instance.e1
	e2=instance.e2
	k=instance.k
	e=instance.e
	m1=instance.m1
	m2=instance.m2
	F=instance.F
	a=instance.a
	H=instance.H
	c=instance.c
	P=instance.P
	X=instance.X
	R=instance.R
	Y=instance.Y
	f=instance.f
	h=instance.h
	g=instance.g
    ###print ('lengths', len(w), len(k))
	if len(w)!=len(vk):
		raise Exception("inputs to psi_RMFE must be of same length")
	for i in range(len(vk)): 
		if vk[i]>k:
			raise Exception("every coordinate on second input of psi_RMFE need to be at most k")
	B=[a**i for i in range(e1)]
	data=FFTpreproc(e1,B)
    	
	res=[]
	for j in range(len(w)):
 	#First change field representation to represent input as element of F_(m1^e2) and hence as a polynomial in F[X] of degree at most e2.
		p=field_iso_asc(w[j],e1,g,R)
		p=list(p)
    		#print ('After translating to F', p)
		
    		#Before applying the FFT we need to a polynomial of degree <=m1. For this we take modulo X^m1+X, as this does not modify evaluation in points of F=F_m1:
		hredi=listsum(p[_sage_const_0 :m1],[_sage_const_0 ]+p[m1:_sage_const_2 *m1-_sage_const_1 ])
		hred=listsum(hredi[:],[_sage_const_0 ]+p[_sage_const_2 *m1-_sage_const_1 :])
    		#print ('After reduction', hred)
		
    
    		#Apply FFT
		w1=eval(hred,instance)
    
        	#print ('After applying FFT we get', w1)
    
    		#At this point we have a vector w1 of m1 elements in F and want to apply psi_first to each of these coordinates (obtaining k1 coordinates in F2 at each of these m1). If we apply it directly we get an output of m1*k1 coordinates, buit this may not coincide with vk[j], because: first, the theory also allows to have one more point, the point at infinity so in fact vk[j] may be as large as (m1+1)*k1; second, it also maybe that vk[j]<m1*k1. So based on value of vk, we adjust size of the output. If vk is larger than m1*k1 we need to add the evaluation in the point at infinity. If it is smaller we adjust so that the output will have vk[j] coordinates

		if vk[j]>m1*k1:
			if len(p)>_sage_const_2 *m1:
				w1.append(p[_sage_const_2 *m1])
			else:
				w1.append([_sage_const_0 ]*(vk[j]-len(p)))
		else:
			
			upper=((vk[j]-_sage_const_1 )//k1) + _sage_const_1 	
			del w1[upper:]
		
    	###print ('After adjusting we get', w1)

    	#Apply psi_first to each element of resulting vector.
		r=[]
		for i in range(len(w1)):
			r=r+psi_first(w1[i],instance)
    
    	#Adjust size of output.
		del r[vk[j]:]
        #Concatenate this to global vector.
		res=res+r
	return res



