
# This file was *autogenerated* from the file FFTa.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0)#!/usr/bin/env sage

from sys import *
from lowlevel import *
from taylor import *
from pypolyfunctions import *


#Implementation in Sage of Gao-Mateer10 first additive binary FFT algorithm, and its inverse.

def binaryFFT(f,m,B,data): #f is the polynomial of degree <n=2^m=q, B is a basis of Fq over F2 
	f=list(f)
	m1=len(data[-_sage_const_1 ])
	if m==_sage_const_1 :
		return (f[_sage_const_0 ],f[_sage_const_0 ]+B[_sage_const_0 ]*f[_sage_const_1 ])
	else:
		G,D=data[-m]
		#binv=data[-1][m1-m+1]
		K=_sage_const_1 <<m-_sage_const_1 
		M=K<<_sage_const_1 
        
		g=comp_cX(f,B[-_sage_const_1 ])
	                                                              
		b=Taylor(g,M)
		gzero=map(lambda x:x[_sage_const_0 ], b) 
		gone=map(lambda x:x[_sage_const_1 ], b) 
        
		u=binaryFFT(gzero,m-_sage_const_1 ,D,data)
		v=binaryFFT(gone,m-_sage_const_1 ,D,data)
		
		Li=lin(G)                                                                                        
		w=map(lambda x,y,z:x+y*z, u,Li,v)
		w1=map(lambda x,y:x+y, w,v) 

		return w+w1 

def invbinaryFFT(w,m,B,data):
#Inverse of previous algorithm.
	if m==_sage_const_1 :
		if len(w)==_sage_const_1 :
			return [w[_sage_const_0 ]]
		else:
			return [w[_sage_const_0 ],(w[_sage_const_0 ]+w[_sage_const_1 ])*B[_sage_const_0 ]**(-_sage_const_1 )]
	else:
		G,D=data[-m]
		Li=lin(G)
		K=_sage_const_1 <<m-_sage_const_1 
		M=K<<_sage_const_1 
		
		v=map(lambda x,y:x-y, w[K:_sage_const_2 *K],w[_sage_const_0 :K])
		u=map(lambda x,y,z: x-y*z, w[_sage_const_0 :K],Li,v)		
		
		gzero=invbinaryFFT(u,m-_sage_const_1 ,D,data)
		gone=invbinaryFFT(v,m-_sage_const_1 ,D,data)
		
		f=combine(gzero,gone,B[-_sage_const_1 ]**(-_sage_const_1 ))
		
		return f+[_sage_const_0 ]*(M-len(f))




