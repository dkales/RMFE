

from lowlevel import lin
from FFTa import *
from FFTpreproc import *



#Interpolates a polynomial over field F, an extension of F_2 generated by a, in the points 0,1,a,1+a,a^2,1+a^2,...
#In certain cases, it calls a faster binary Fast Fourier transform implemented in another module.
def interpol(w,instance):
	e1=instance.e1
	m1=instance.m1	
	F=instance.F
	a=instance.a
	R=instance.R
	Y=instance.Y

	B=[a^i for i in range(e1)]
	if len(w)==2**e1 or len(w)==2**e1+1:
		
		data=FFTpreproc(e1,B)
		v2=invbinaryFFT(w,e1,B,data)
		p=0
		for i in range(len(v2)):
			p+=v2[i]*Y^i
		#Adjust evaluation at point at infinity if necessary. 
		if len(w)==2**e1+1:
			p+=w[m1]*(Y^m1-Y)
		return p	
	else:
		EvalPoints=lin(B)[:len(w)]
		Points=[(EvalPoints[i],w[i]) for i in range(len(w))]
		return R.lagrange_polynomial(Points)


#Evaluates a polynomial over field F, an extension of F_2 generated by a, in the points 0,1,a,1+a,a^2,1+a^2,...
#In certain cases, it calls a faster binary Fast Fourier transform implemented in another module.
#Polynomial is given as a list of coeff

def eval(p,instance):
	e1=instance.e1
	F=instance.F
	a=instance.a
	R=instance.R
	Y=instance.Y
	B=[a^i for i in range(e1)]

	
	if len(p)==2**e1 or 2**e1+1:
		
		data=FFTpreproc(e1,B)
		v2=binaryFFT(p,e1,B,data)
		return v2
			
	else:
		EvalPoints=lin(B)[:len(p)]
		return [R(p)(EvalPoints[i]) for i in range(len(p))]

